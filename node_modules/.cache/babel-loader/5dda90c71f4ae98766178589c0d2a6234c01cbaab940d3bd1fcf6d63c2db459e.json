{"ast":null,"code":"const R_SHORT=0.01;// per spec suggestion :contentReference[oaicite:14]{index=14}\nconst R_OPEN=Number.POSITIVE_INFINITY;const R_HIGH_ADD=5;// per spec example (+5立) :contentReference[oaicite:15]{index=15}\nexport function clamp(n,min,max){return Math.max(min,Math.min(max,n));}export function round1(n){return Math.round(n*10)/10;}export function round2(n){return Math.round(n*100)/100;}export function effectiveResistance(rUser,fault){const r=clamp(rUser,1,25);switch(fault){case\"normal\":return r;case\"high\":return r+R_HIGH_ADD;case\"open\":return R_OPEN;case\"short\":return R_SHORT;default:return r;}}export function faultDescription(fault){switch(fault){case\"high\":return\"High Resistance: corrosion or poor connection.\";case\"open\":return\"Open Circuit: broken wire or open switch.\";case\"short\":return\"Short Circuit: wire rubbed through to ground.\";default:return\"\";}}export function calcCircuit(opts){const{circuitType,sourceV,switchClosed,loads}=opts;// If switch is open: no current anywhere (acts like open circuit)\nif(!switchClosed){return{sourceV,totalR:Number.POSITIVE_INFINITY,totalI:0,totalP:0,rows:loads.map((l,idx)=>({label:\"Load \".concat(idx+1),v:0,i:0,r:effectiveResistance(l.rUser,l.fault),p:0,status:\"Switch Open\"})),faultNotes:[],hasFlow:false,branchCurrents:circuitType===\"parallel\"?loads.map(()=>0):undefined,elementPowers:loads.map(()=>0)};}const effR=loads.map(l=>effectiveResistance(l.rUser,l.fault));const notes=[];loads.forEach(l=>{const d=faultDescription(l.fault);if(d)notes.push(d);});if(circuitType===\"simple\"){const r1=effR[0];const totalR=r1;const totalI=isFinite(totalR)?sourceV/totalR:0;const v1=sourceV;// simple loop\nconst p1=v1*totalI;return{sourceV,totalR,totalI,totalP:p1,rows:[{label:\"Load 1\",v:v1,i:totalI,r:r1,p:p1,status:loads[0].fault===\"normal\"?\"Normal\":loads[0].fault}],faultNotes:notes,hasFlow:totalI>0.0001,elementPowers:[p1]};}if(circuitType===\"series\"){// Any open in series -> total current ~0\nconst hasOpen=effR.some(r=>!isFinite(r));if(hasOpen){return{sourceV,totalR:Number.POSITIVE_INFINITY,totalI:0,totalP:0,rows:loads.map((l,idx)=>({label:\"Load \".concat(idx+1),v:0,i:0,r:effR[idx],p:0,status:l.fault===\"open\"?\"Open Circuit\":l.fault===\"normal\"?\"Normal\":l.fault})),faultNotes:notes.length?notes:[\"Open circuit in series: loop current is ~0 A.\"],hasFlow:false,elementPowers:loads.map(()=>0)};}const totalR=effR.reduce((a,b)=>a+b,0);const totalI=sourceV/totalR;const rows=[];const powers=[];for(let i=0;i<loads.length;i++){const v=totalI*effR[i];const p=totalI*totalI*effR[i];powers.push(p);rows.push({label:\"Load \".concat(i+1),v,i:totalI,r:effR[i],p,status:loads[i].fault===\"normal\"?\"Normal\":loads[i].fault});}return{sourceV,totalR,totalI,totalP:rows.reduce((s,r)=>s+r.p,0),rows,faultNotes:notes,hasFlow:totalI>0.0001,elementPowers:powers};}// parallel\nconst branchI=[];const rows=[];const powers=[];for(let i=0;i<loads.length;i++){const r=effR[i];const iBranch=isFinite(r)?sourceV/r:0;const p=sourceV*iBranch;branchI.push(iBranch);powers.push(p);rows.push({label:\"Load \".concat(i+1),v:sourceV,i:iBranch,r,p,status:loads[i].fault===\"normal\"?\"Normal\":loads[i].fault});}const totalI=branchI.reduce((a,b)=>a+b,0);const totalR=totalI>0?sourceV/totalI:Number.POSITIVE_INFINITY;const totalP=powers.reduce((a,b)=>a+b,0);// Add a helpful note if a short exists\nif(loads.some(l=>l.fault===\"short\")){notes.push(\"A shorted branch has nearly 0 立, so it draws most of the current.\");}return{sourceV,totalR,totalI,totalP,rows,faultNotes:notes,hasFlow:totalI>0.0001,branchCurrents:branchI,elementPowers:powers};}","map":{"version":3,"names":["R_SHORT","R_OPEN","Number","POSITIVE_INFINITY","R_HIGH_ADD","clamp","n","min","max","Math","round1","round","round2","effectiveResistance","rUser","fault","r","faultDescription","calcCircuit","opts","circuitType","sourceV","switchClosed","loads","totalR","totalI","totalP","rows","map","l","idx","label","concat","v","i","p","status","faultNotes","hasFlow","branchCurrents","undefined","elementPowers","effR","notes","forEach","d","push","r1","isFinite","v1","p1","hasOpen","some","length","reduce","a","b","powers","s","branchI","iBranch"],"sources":["C:/Users/Bill Smithingell/Downloads/electrasim/src/logic/electrical.ts"],"sourcesContent":["export type FaultType = \"normal\" | \"high\" | \"open\" | \"short\";\r\nexport type CircuitType = \"simple\" | \"series\" | \"parallel\";\r\n\r\nexport interface LoadConfig {\r\n  rUser: number; // user-entered resistance\r\n  fault: FaultType;\r\n}\r\n\r\nexport interface ElementRow {\r\n  label: string;\r\n  v: number; // volts across element\r\n  i: number; // amps through element (series: same for all)\r\n  r: number; // effective resistance used in math\r\n  p: number; // watts\r\n  status: string;\r\n}\r\n\r\nexport interface CalcResult {\r\n  sourceV: number;\r\n  totalR: number; // Infinity if open / no current\r\n  totalI: number;\r\n  totalP: number;\r\n  rows: ElementRow[];\r\n  faultNotes: string[]; // short descriptions for right panel\r\n  hasFlow: boolean; // whether electrons should move\r\n  branchCurrents?: number[]; // for parallel animation splitting\r\n  elementPowers: number[]; // per load power (for brightness)\r\n}\r\n\r\nconst R_SHORT = 0.01; // per spec suggestion :contentReference[oaicite:14]{index=14}\r\nconst R_OPEN = Number.POSITIVE_INFINITY;\r\nconst R_HIGH_ADD = 5; // per spec example (+5立) :contentReference[oaicite:15]{index=15}\r\n\r\nexport function clamp(n: number, min: number, max: number) {\r\n  return Math.max(min, Math.min(max, n));\r\n}\r\n\r\nexport function round1(n: number) {\r\n  return Math.round(n * 10) / 10;\r\n}\r\nexport function round2(n: number) {\r\n  return Math.round(n * 100) / 100;\r\n}\r\n\r\nexport function effectiveResistance(rUser: number, fault: FaultType): number {\r\n  const r = clamp(rUser, 1, 25);\r\n  switch (fault) {\r\n    case \"normal\":\r\n      return r;\r\n    case \"high\":\r\n      return r + R_HIGH_ADD;\r\n    case \"open\":\r\n      return R_OPEN;\r\n    case \"short\":\r\n      return R_SHORT;\r\n    default:\r\n      return r;\r\n  }\r\n}\r\n\r\nexport function faultDescription(fault: FaultType): string {\r\n  switch (fault) {\r\n    case \"high\":\r\n      return \"High Resistance: corrosion or poor connection.\";\r\n    case \"open\":\r\n      return \"Open Circuit: broken wire or open switch.\";\r\n    case \"short\":\r\n      return \"Short Circuit: wire rubbed through to ground.\";\r\n    default:\r\n      return \"\";\r\n  }\r\n}\r\n\r\nexport function calcCircuit(opts: {\r\n  circuitType: CircuitType;\r\n  sourceV: number;\r\n  switchClosed: boolean;\r\n  loads: LoadConfig[]; // already sliced to active count\r\n}): CalcResult {\r\n  const { circuitType, sourceV, switchClosed, loads } = opts;\r\n\r\n  // If switch is open: no current anywhere (acts like open circuit)\r\n  if (!switchClosed) {\r\n    return {\r\n      sourceV,\r\n      totalR: Number.POSITIVE_INFINITY,\r\n      totalI: 0,\r\n      totalP: 0,\r\n      rows: loads.map((l, idx) => ({\r\n        label: `Load ${idx + 1}`,\r\n        v: 0,\r\n        i: 0,\r\n        r: effectiveResistance(l.rUser, l.fault),\r\n        p: 0,\r\n        status: \"Switch Open\",\r\n      })),\r\n      faultNotes: [],\r\n      hasFlow: false,\r\n      branchCurrents:\r\n        circuitType === \"parallel\" ? loads.map(() => 0) : undefined,\r\n      elementPowers: loads.map(() => 0),\r\n    };\r\n  }\r\n\r\n  const effR = loads.map((l) => effectiveResistance(l.rUser, l.fault));\r\n  const notes: string[] = [];\r\n  loads.forEach((l) => {\r\n    const d = faultDescription(l.fault);\r\n    if (d) notes.push(d);\r\n  });\r\n\r\n  if (circuitType === \"simple\") {\r\n    const r1 = effR[0];\r\n    const totalR = r1;\r\n    const totalI = isFinite(totalR) ? sourceV / totalR : 0;\r\n    const v1 = sourceV; // simple loop\r\n    const p1 = v1 * totalI;\r\n\r\n    return {\r\n      sourceV,\r\n      totalR,\r\n      totalI,\r\n      totalP: p1,\r\n      rows: [\r\n        {\r\n          label: \"Load 1\",\r\n          v: v1,\r\n          i: totalI,\r\n          r: r1,\r\n          p: p1,\r\n          status: loads[0].fault === \"normal\" ? \"Normal\" : loads[0].fault,\r\n        },\r\n      ],\r\n      faultNotes: notes,\r\n      hasFlow: totalI > 0.0001,\r\n      elementPowers: [p1],\r\n    };\r\n  }\r\n\r\n  if (circuitType === \"series\") {\r\n    // Any open in series -> total current ~0\r\n    const hasOpen = effR.some((r) => !isFinite(r));\r\n    if (hasOpen) {\r\n      return {\r\n        sourceV,\r\n        totalR: Number.POSITIVE_INFINITY,\r\n        totalI: 0,\r\n        totalP: 0,\r\n        rows: loads.map((l, idx) => ({\r\n          label: `Load ${idx + 1}`,\r\n          v: 0,\r\n          i: 0,\r\n          r: effR[idx],\r\n          p: 0,\r\n          status:\r\n            l.fault === \"open\"\r\n              ? \"Open Circuit\"\r\n              : l.fault === \"normal\"\r\n              ? \"Normal\"\r\n              : l.fault,\r\n        })),\r\n        faultNotes: notes.length\r\n          ? notes\r\n          : [\"Open circuit in series: loop current is ~0 A.\"],\r\n        hasFlow: false,\r\n        elementPowers: loads.map(() => 0),\r\n      };\r\n    }\r\n\r\n    const totalR = effR.reduce((a, b) => a + b, 0);\r\n    const totalI = sourceV / totalR;\r\n\r\n    const rows: ElementRow[] = [];\r\n    const powers: number[] = [];\r\n    for (let i = 0; i < loads.length; i++) {\r\n      const v = totalI * effR[i];\r\n      const p = totalI * totalI * effR[i];\r\n      powers.push(p);\r\n      rows.push({\r\n        label: `Load ${i + 1}`,\r\n        v,\r\n        i: totalI,\r\n        r: effR[i],\r\n        p,\r\n        status: loads[i].fault === \"normal\" ? \"Normal\" : loads[i].fault,\r\n      });\r\n    }\r\n\r\n    return {\r\n      sourceV,\r\n      totalR,\r\n      totalI,\r\n      totalP: rows.reduce((s, r) => s + r.p, 0),\r\n      rows,\r\n      faultNotes: notes,\r\n      hasFlow: totalI > 0.0001,\r\n      elementPowers: powers,\r\n    };\r\n  }\r\n\r\n  // parallel\r\n  const branchI: number[] = [];\r\n  const rows: ElementRow[] = [];\r\n  const powers: number[] = [];\r\n\r\n  for (let i = 0; i < loads.length; i++) {\r\n    const r = effR[i];\r\n    const iBranch = isFinite(r) ? sourceV / r : 0;\r\n    const p = sourceV * iBranch;\r\n    branchI.push(iBranch);\r\n    powers.push(p);\r\n    rows.push({\r\n      label: `Load ${i + 1}`,\r\n      v: sourceV,\r\n      i: iBranch,\r\n      r,\r\n      p,\r\n      status: loads[i].fault === \"normal\" ? \"Normal\" : loads[i].fault,\r\n    });\r\n  }\r\n\r\n  const totalI = branchI.reduce((a, b) => a + b, 0);\r\n  const totalR = totalI > 0 ? sourceV / totalI : Number.POSITIVE_INFINITY;\r\n  const totalP = powers.reduce((a, b) => a + b, 0);\r\n\r\n  // Add a helpful note if a short exists\r\n  if (loads.some((l) => l.fault === \"short\")) {\r\n    notes.push(\r\n      \"A shorted branch has nearly 0 立, so it draws most of the current.\"\r\n    );\r\n  }\r\n\r\n  return {\r\n    sourceV,\r\n    totalR,\r\n    totalI,\r\n    totalP,\r\n    rows,\r\n    faultNotes: notes,\r\n    hasFlow: totalI > 0.0001,\r\n    branchCurrents: branchI,\r\n    elementPowers: powers,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}